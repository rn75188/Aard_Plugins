<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, February 11, 2024, 9:18 AM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "Bypass" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Bypass"
   author="Tipro"
   id="95422031fcf206453f347fa7"
   language="Lua"
   purpose="Handle and auto set bypass areas"
   date_written="2024-02-11 09:17:33"
   requires="5.07"
   version="1.0"
   >

</plugin>


<!--  Triggers  -->
<triggers>

	<trigger match="^You raise a level! You are now level (\d+)\."
		script="bypass_level"
		enabled="y" sequence="100" regexp="y" send_to="12" > </trigger>

</triggers>


<aliases>

	<alias
		match="^bypass_help?"
		script="bypass_help"
        enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

    <alias
		match="^(?:bypass_add)(?: (\d+))?(?: (\w+))?"
		script="bypass_add"
        enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias
		match="^bypass_remove(?: (\d+))?"
		script="bypass_remove"
        enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias
		match="^bypass_list?"
		script="bypass_list"
        enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

	<alias
		match="^bypass_set?"
		script="bypass_set"
        enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>


	<alias
		match="^bypass_clear?"
		script="bypass_clear"
        enabled="y" regexp="y" sequence="100" ignore_case="y" send_to="12" > </alias>

</aliases>


<script>

current_level = 0

require("gmcphelper")
function OnPluginBroadcast(msg, id, name, text)
	if id ~= "3e7dedbe37e44942dd46d264" then -- message from the GMCP Handler
		return end
	
	if (text == "char.status") then
       charstatus = gmcp("char.status")
       current_level = tonumber(charstatus.level)
	elseif (text == "char.stats") then
		charstats = gmcp("char.stats")
		current_wis = tonumber(charstats.wis)
		current_int = tonumber(charstats.int)
	end
end


-- [[ Plugin installation ]]
function OnPluginInstall()
	local db_path = GetInfo(66) .. "\\bypass.db"
	local db = assert(sqlite3.open(db_path))
	
	create_bypass_table(db)
	
	db:close()
	print("Database initialized.")
	print(" ")
	print("Type bypass_help to see available commands")
end

function create_bypass_table(db)
	local db_tables = {}
	local query = "SELECT name FROM sqlite_master WHERE type='table'"
	local create_tables = {}
	
	for row in db:nrows(query) do
		db_tables[row.name] = true
	end
	
	if not db_tables["bypass_list"] then
		print("Creating table 'bypass_list'")
		table.insert(create_tables, [[
			CREATE TABLE bypass_list (
				id INTEGER PRIMARY KEY AUTOINCREMENT,
				area TEXT NOT NULL,
				level INTEGER NOT NULL
			);
		]])
	end
	
	if #create_tables > 0 then
		db:execute(table.concat(create_tables,""))
	end
end

function bypass_help()
	print(" ")
	print("Commands for bypass plugin:")
	print(" ")
	print("bypass_list: Display current bypass list")
	print("bypass_add [level] [area]: To add to the bypass list")
	print("bypass_remove [ID]: To remove a specific entry from bypass list")
	print("bypass_set: Reset bypassed areas")
	print("bypass_clear: Clear entire bypass_list")
end

function bypass_add(name,line,wildcards)
	print("Adding to bypass table")

	local bypass_level = tonumber(wildcards[1])
	local bypass_area = wildcards[2]

	if not bypass_level or not bypass_area then
		print("Error: Must be bypass_add [number] [area]")
		return
	end

	local db_path = GetInfo(66) .. "\\bypass.db"
	local db = assert(sqlite3.open(db_path))

	--Ensure user doesn't have too many areas bypassed for that level--
	local check_query = string.format("SELECT COUNT(*) as count FROM bypass_list WHERE level == %d", bypass_level)
	local count
	for result in db:nrows(check_query) do
		count = result.count
		break
	end
	
	if (count > 2 and 200 > bypass_level) or (count > 3 and bypass_level == 200) then
		print("Too many areas entered for this level. Remove one (bypass_remove [ID]) and try again.")
		local details_query = string.format("SELECT level, area, id FROM bypass_list WHERE level == %d", bypass_level)
		for row in db:nrows(details_query) do
			print("Level: " .. row.level .. ", Area: " .. row.area .. ", ID: " .. row.id)
		end
		return
	else
		local insert_sql = string.format("INSERT INTO bypass_list (level, area) VALUES (%d, '%s');", bypass_level, bypass_area)
		local result, err = db:execute(insert_sql)
		if not result then
			Note("Error inserting bypass: " .. tostring(err))
		else
			Note("Bypass added for area '" .. bypass_area .. "' with level " .. bypass_level)
		end
	end
	db:close()
end

function bypass_remove(name,line,wildcards)
	local bypass_remove = tonumber(wildcards[1])
		
	local db_path = GetInfo(66) .. "\\bypass.db"
    local db = assert(sqlite3.open(db_path))
	
	local entry_query = string.format("SELECT * FROM bypass_list WHERE id = %d", bypass_remove)
	local entry = db:nrows(entry_query)
	local count = 0
	for _ in db:nrows(entry_query) do
		count = count + 1
	end
	
	if bypass_remove == nil or count == 0 then
		Note("Error: Must enter valid bypass_list ID number")
		Note("")
		bypass_list()
		return
	else
		Note("")
		print("Removing item from bypass_list")
		local delete_query = string.format("DELETE FROM bypass_list WHERE id = %d", bypass_remove)
		local result, err = db:execute(delete_query)
		if not result then
			Note("Error deleting entry: " ..tostring(err))
		else
			Note("Entry with ID " .. bypass_remove .. " successfully removed.")
		end
	end
	
	bypass_list()
	
	db:close()
	
end

function bypass_list()
    Note("")
	Note("Current Level: " .. current_level)
	Note("Bypass List:")

    local db_path = GetInfo(66) .. "\\bypass.db"
    local db = assert(sqlite3.open(db_path))

    local query_sql = "SELECT * FROM bypass_list ORDER BY level ASC, area ASC;"
    for row in db:nrows(query_sql) do
        if row.id == nil then
            Note("Missing 'id' in row. Row content: " .. tostring(row))
        else
            Note("Level: " .. row.level .. ", Area: " .. row.area .. ", ID: " .. row.id)
        end
    end

    db:close()
end

function bypass_set()
	print("Called bypass_set")
	local bypass_level = current_level

	if not bypass_level or bypass_level == 0 then
        print("Don't see current level. Go kill something and try again!")
        return
	end
	
	print("Current level: " .. bypass_level)
	bypass_update(bypass_level)
end

function bypass_level (name,line,wildcards)
	print("New level detected")
	local new_level = tonumber(wildcards[1])
	print(new_level)

	local db_path = GetInfo(66) .. "\\bypass.db"
    local db = assert(sqlite3.open(db_path))
	
	local entry_query = string.format("SELECT * FROM bypass_list WHERE level = %d", new_level)
	local entry = db:nrows(entry_query)
	local count = 0
	for _ in db:nrows(entry_query) do
		count = count + 1
	end
--	print(count)
			
	if count > 0 then
		bypass_update(new_level)
	end

	db:close()
end

function bypass_update(bypass_level)
	local db_path = GetInfo(66) .. "\\bypass.db"
    local db = assert(sqlite3.open(db_path))

	local max_bypass = 2
	if current_int + current_wis >= 400 and 600 > current_int + current_wis then 
		max_bypass = 3
	elseif current_int + current_wis == 600 then 
		max_bypass = 4
	end

	print(bypass_level)

	local query_sql = string.format("SELECT * FROM bypass_list WHERE %d >= level ORDER BY level DESC, id ASC LIMIT %d;", bypass_level, max_bypass)
    local entries = {}
	Send("bypass clear")
	for row in db:nrows(query_sql) do
        print("Resetting to: " .. row.area)
		Send("bypass " .. row.area)
    end

    for i, entry in ipairs(entries) do
        print("Bypass areas: ID " .. entry.id .. ", Area: " .. entry.area .. ", Level: " .. entry.level)
    end
	
	db:close()
end


function bypass_clear()
    local db_path = GetInfo(66) .. "\\bypass.db"
    local db = assert(sqlite3.open(db_path))
    
    -- Drop the existing table
    db:execute("DROP TABLE IF EXISTS bypass_list;")
    Note("Bypass table cleared")

    -- Recreate the table
    print("Recreating table 'bypass_list'")
	create_bypass_table(db)

    db:close()  -- Close the database connection
end


</script>


</muclient>
